From 3bc38571b8ef5f7b1ff751d809c66d33103bacb0 Mon Sep 17 00:00:00 2001
From: Phares CHAKOUR <chakour.phares@gmail.com>
Date: Tue, 24 Mar 2020 16:31:20 +0100
Subject: [PATCH] [PATCH] Migration Kibana 7.6.X

---
 index.js                         |   11 -
 index.ts                         |   17 +
 package.json                     |    5 +-
 public/index.ts                  |    6 +
 public/legacy.ts                 |   15 +
 public/network_vis.html          |    4 +-
 public/network_vis.js            |  191 ++--
 public/network_vis_controller.js | 1397 +++++++++++++++---------------
 public/network_vis_params.html   |   46 +-
 public/plugin.ts                 |   25 +
 10 files changed, 889 insertions(+), 828 deletions(-)
 delete mode 100644 index.js
 create mode 100644 index.ts
 create mode 100644 public/index.ts
 create mode 100644 public/legacy.ts
 create mode 100644 public/plugin.ts

diff --git a/index.js b/index.js
deleted file mode 100644
index 7d351b1..0000000
--- a/index.js
+++ /dev/null
@@ -1,11 +0,0 @@
-export default function (kibana) {
-
-  return new kibana.Plugin({
-    uiExports: {
-      visTypes: [
-        'plugins/network_vis/network_vis'
-      ]
-    }
-  });
-
-}
diff --git a/index.ts b/index.ts
new file mode 100644
index 0000000..b47d7d4
--- /dev/null
+++ b/index.ts
@@ -0,0 +1,17 @@
+import { resolve } from 'path';
+import { Legacy } from 'kibana';
+
+import { LegacyPluginApi, LegacyPluginInitializer } from '../../src/legacy/types';
+
+const networkVisPluginInitializer: LegacyPluginInitializer = ({ Plugin }: LegacyPluginApi) =>
+  new Plugin({
+    id: 'network_vis',
+    require: ['kibana', 'elasticsearch', 'interpreter'],
+    publicDir: resolve(__dirname, 'public'),
+    uiExports: {
+      hacks: [resolve(__dirname, 'public/legacy')],
+      injectDefaultVars: server => ({}),
+    }
+  } as Legacy.PluginSpecOptions);
+
+export default networkVisPluginInitializer;
diff --git a/package.json b/package.json
index d87e3dc..7c3b64b 100644
--- a/package.json
+++ b/package.json
@@ -13,9 +13,8 @@
     "url": "https://github.com/dlumbrer/kbn_network"
   },
   "dependencies": {
-    "vis-network": "7.2.0",
-    "randomcolor": "0.5.0",
-    "css-element-queries": "0.3.2",
+    "vis-network": "^7.4.0",
+    "randomcolor": "^0.5.0",
     "keycharm": "^0.2.0",
     "moment": "^2.24.0",
     "vis-data": "^6.2.1",
diff --git a/public/index.ts b/public/index.ts
new file mode 100644
index 0000000..c7188b1
--- /dev/null
+++ b/public/index.ts
@@ -0,0 +1,6 @@
+import { PluginInitializerContext } from '../../../src/core/public';
+import { NetworkVisPlugin as Plugin } from './plugin';
+
+export function plugin(initializerContext: PluginInitializerContext) {
+  return new Plugin(initializerContext);
+}
diff --git a/public/legacy.ts b/public/legacy.ts
new file mode 100644
index 0000000..470370a
--- /dev/null
+++ b/public/legacy.ts
@@ -0,0 +1,15 @@
+import { PluginInitializerContext } from 'kibana/public';
+import { npSetup, npStart } from 'ui/new_platform';
+
+import { setup as visualizationsSetup } from '../../../src/legacy/core_plugins/visualizations/public/np_ready/public/legacy';
+import { NetworkVisPluginSetupDependencies } from './plugin';
+import { plugin } from '.';
+
+const plugins: Readonly<NetworkVisPluginSetupDependencies> = {
+  visualizations: visualizationsSetup,
+};
+
+const pluginInstance = plugin({} as PluginInitializerContext);
+
+export const setup = pluginInstance.setup(npSetup.core, plugins);
+export const start = pluginInstance.start(npStart.core);
diff --git a/public/network_vis.html b/public/network_vis.html
index 2b4ba6f..0334dfb 100644
--- a/public/network_vis.html
+++ b/public/network_vis.html
@@ -1,7 +1,7 @@
 <div id="errorHtml"></div>
-<div ng-controller="KbnNetworkVisController" class="network-vis" id="net_{{$id}}" ng-style="{'background-color':vis.params.canvasBackgroundColor}">
+<div ng-controller="KbnNetworkVisController" class="network-vis" id="net_{{$id}}">
 </div>
-<div id="loading_{{$id}}" ng-style="{'background-color':vis.params.canvasBackgroundColor}">
+<div id="loading_{{$id}}">
   <div class="loading_msg">
     <p><strong>Loading network...</strong><i class="fa fa-clock-o" aria-hidden="true"></i></p>
   </div>
diff --git a/public/network_vis.js b/public/network_vis.js
index 963f4d3..57b8d8b 100644
--- a/public/network_vis.js
+++ b/public/network_vis.js
@@ -1,112 +1,95 @@
-import "plugins/network_vis/network_vis.less";
+import 'plugins/network_vis/network_vis.less';
 
-import { KbnNetworkVisController } from './network_vis_controller'
-import { visFactory } from 'ui/vis/vis_factory';
+import './network_vis_controller';
 import { Schemas } from 'ui/vis/editors/default/schemas';
-import { setup as visualizations } from '../../../src/legacy/core_plugins/visualizations/public/np_ready/public/legacy';
 import image from './images/icon-network.svg';
 import networkVisTemplate from 'plugins/network_vis/network_vis.html';
 import networkVisParamsTemplate from 'plugins/network_vis/network_vis_params.html';
 import { AngularVisController } from 'ui/vis/vis_types/angular_vis_type';
 
-// register the provider with the visTypes registry
-visualizations.types.registerVisualization(NetworkVisTypeProvider);
-
-// define the TableVisType
-function NetworkVisTypeProvider(Private) {
-
-  // return the visType object, which kibana will use to display and configure new
-  // Vis object of this type.
-  return visFactory.createBaseVisualization({
-    name: 'network',
-    title: 'Network',
-    image,
-    description: 'Displays a network node that link two fields that have been selected.',
-    visualization: AngularVisController,
-    visConfig: {
-      defaults: {
-        showLabels: true,
-        showPopup: true,
-        showColorLegend: true,
-        nodePhysics: true,
-        firstNodeColor: '#6F86D7',
-        secondNodeColor: '#DAA05D',
-        canvasBackgroundColor: '#FFFFFF',
-        shapeFirstNode: 'dot',
-        shapeSecondNode: 'box',
-        displayArrow: false,
-        posArrow: 'to',
-        shapeArrow: 'arrow',
-        smoothType: 'continuous',
-        scaleArrow: 1,
-        minCutMetricSizeNode: 0,
-        maxNodeSize: 80,
-        minNodeSize: 8,
-        maxEdgeSize: 20,
-        minEdgeSize: 0.1,
-        springConstant: 0.001,
-        gravitationalConstant: -35000,
-        labelColor: '#000000'
-      },
-      template: networkVisTemplate,
-    },
-    editorConfig: {
-      optionsTemplate: networkVisParamsTemplate,
-      schemas: new Schemas([
-        {
-          group: 'metrics',
-          name: 'size_node',
-          title: 'Node Size',
-          mustBeFirst: 'true',
-          min: 1,
-          max: 1,
-          defaults: [
-            { type: 'count', schema: 'size_node' }
-          ]
-        },
-        {
-          group: 'metrics',
-          name: 'size_edge',
-          title: 'Edge Size',
-          max: 1,
-        },
-        {
-          group: 'buckets',
-          name: 'first',
-          icon: 'fa fa-circle-thin',
-          mustBeFirst: 'true',
-          title: 'Node',
-          min: 1,
-          max: 2,
-          aggFilter: ['terms']//Only have sense choose terms
-        },
-        {
-          group: 'buckets',
-          name: 'second',
-          icon: 'fa fa-random',
-          title: 'Relation',
-          max: 1,
-          aggFilter: ['terms']
-        },
-        {
-          group: 'buckets',
-          name: 'colornode',
-          icon: 'fa fa-paint-brush',
-          title: 'Node Color',
-          max: 1,
-          aggFilter: ['terms']
-        }
-      ])
+export const networkVisTypeDefinition = {
+  name: 'network',
+  title: 'Network',
+  image,
+  description: 'Displays a network node that link two fields that have been selected.',
+  visualization: AngularVisController,
+  visConfig: {
+    defaults: {
+      showLabels: true,
+      showPopup: true,
+      showColorLegend: true,
+      nodePhysics: true,
+      firstNodeColor: '#6F86D7',
+      secondNodeColor: '#DAA05D',
+      shapeFirstNode: 'dot',
+      shapeSecondNode: 'box',
+      displayArrow: false,
+      posArrow: 'to',
+      shapeArrow: 'arrow',
+      smoothType: 'continuous',
+      scaleArrow: 1,
+      minCutMetricSizeNode: 0,
+      maxNodeSize: 80,
+      minNodeSize: 8,
+      maxEdgeSize: 20,
+      minEdgeSize: 0.1,
+      springConstant: 0.001,
+      gravitationalConstant: -35000,
+      labelColor: '#000000',
     },
-    responseHandlerConfig: {
-      asAggConfigResults: true
-    },
-    // structures the data tables (returned by kibana in resp and in UI Inspect)
-    hierarchicalData: function (vis) {
-      return true;
-    },
-  });
-}
-
-export default NetworkVisTypeProvider;
-
+    template: networkVisTemplate,
+  },
+  editorConfig: {
+    optionsTemplate: networkVisParamsTemplate,
+    schemas: new Schemas([
+      {
+        group: 'metrics',
+        name: 'size_node',
+        title: 'Node Size',
+        mustBeFirst: 'true',
+        min: 1,
+        max: 1,
+        defaults: [{ type: 'count', schema: 'size_node' }],
+      },
+      {
+        group: 'metrics',
+        name: 'size_edge',
+        title: 'Edge Size',
+        max: 1,
+      },
+      {
+        group: 'buckets',
+        name: 'first',
+        icon: 'fa fa-circle-thin',
+        mustBeFirst: 'true',
+        title: 'Node',
+        min: 1,
+        max: 2,
+        aggFilter: ['terms'], //Only have sense choose terms
+      },
+      {
+        group: 'buckets',
+        name: 'second',
+        icon: 'fa fa-random',
+        title: 'Relation',
+        max: 1,
+        aggFilter: ['terms'],
+      },
+      {
+        group: 'buckets',
+        name: 'colornode',
+        icon: 'fa fa-paint-brush',
+        title: 'Node Color',
+        max: 1,
+        aggFilter: ['terms'],
+      },
+    ]),
+  },
+  responseHandlerConfig: {
+    asAggConfigResults: true,
+  },
+  // structures the data tables (returned by kibana in resp and in UI Inspect)
+  hierarchicalData: function() {
+    return true;
+  },
+};
diff --git a/public/network_vis_controller.js b/public/network_vis_controller.js
index 3bf7787..63d44ba 100644
--- a/public/network_vis_controller.js
+++ b/public/network_vis_controller.js
@@ -1,721 +1,752 @@
 import { uiModules } from 'ui/modules';
-import { AggConfig } from 'ui/agg_types/agg_config';
+import angular from 'angular';
+import randomColor from 'randomcolor';
+import { Network } from 'vis-network';
+// import ResizeSensor from 'css-element-queries/src/ResizeSensor';
+import $ from 'jquery';
 
 // get the kibana/table_vis module, and make sure that it requires the "kibana" module if it
 // didn't already
 const module = uiModules.get('kibana/transform_vis', ['kibana']);
-//import the npm modules
-const visN = require('vis-network');
-const randomColor = require('randomcolor');
-const ElementQueries = require('css-element-queries/src/ElementQueries');
-const ResizeSensor = require('css-element-queries/src/ResizeSensor');
 
 // add a controller to the module, which will transform the esResponse into a
 // tabular format that we can pass to the table directive
-module.controller('KbnNetworkVisController', function ($scope, $sce, $timeout, Private) {
-    var network_id, loading_id;
-
-    $scope.errorNodeColor = function () {
-        $("#" + network_id).hide();
-        $("#" + loading_id).hide();
-        $("#errorHtml").html("<h1><strong>ERROR</strong>: Node Color must be the LAST selection</h1>");
-        $("#errorHtml").show();
+module.controller('KbnNetworkVisController', function($scope, $timeout) {
+  let networkId;
+  let loadingId;
+
+  $scope.errorNodeColor = function() {
+    $('#' + networkId).hide();
+    $('#' + loadingId).hide();
+    $('#errorHtml').html('<h1><strong>ERROR</strong>: Node Color must be the LAST selection</h1>');
+    $('#errorHtml').show();
+  };
+
+  $scope.errorNodeNodeRelation = function() {
+    $('#' + networkId).hide();
+    $('#' + loadingId).hide();
+    $('#errorHtml').html(
+      '<h1><strong>ERROR</strong>: You can only choose Node-Node or Node-Relation</h1>'
+    );
+    $('#errorHtml').show();
+  };
+
+  $scope.initialShows = function() {
+    $('#' + networkId).show();
+    $('#' + loadingId).show();
+    $('#errorHtml').hide();
+  };
+
+  $scope.drawColorLegend = function(usedColors, colorDicc) {
+    const canvas = document.getElementsByTagName('canvas')[0];
+    const context = canvas.getContext('2d');
+
+    // Fill in text
+    context.fillStyle = 'black';
+    context.font = 'bold 30px Arial';
+    context.textAlign = 'start';
+    context.fillText('COLOR LEGEND:', canvas.width * -1, canvas.height * -1);
+
+    let height = 40; // adds a preliminary buffer for the legend title
+    let currentHeightOnCanvas = canvas.height * -1 + height;
+    let largestWidth = context.measureText('COLOR LEGEND:').width;
+
+    for (const key of Object.keys(colorDicc)) {
+      context.fillStyle = colorDicc[key];
+      context.font = 'bold 20px Arial';
+      context.fillText(key, canvas.width * -1, currentHeightOnCanvas);
+      height += 22;
+      currentHeightOnCanvas = canvas.height * -1 + height;
+
+      const currentWidth = context.measureText(key).width;
+      if (currentWidth > largestWidth) {
+        largestWidth = currentWidth;
+      }
     }
 
-    $scope.errorNodeNodeRelation = function () {
-        $("#" + network_id).hide();
-        $("#" + loading_id).hide();
-        $("#errorHtml").html("<h1><strong>ERROR</strong>: You can only choose Node-Node or Node-Relation</h1>");
-        $("#errorHtml").show();
+    // Shade in the legend
+    context.fillStyle = 'rgba(218, 218, 218, 0.25)';
+    context.fillRect(
+      canvas.width * -1 - 20,
+      canvas.height * -1 - 40,
+      largestWidth + 40,
+      height + 60
+    );
+  };
+
+  $scope.$watchMulti(['esResponse', 'vis.params.secondNodeColor'], function([resp]) {
+    // constiables for column ids, ex. id: "col-0-3" from one of the 'columns' in the resp
+    let firstFirstBucketId;
+    let firstSecondBucketId;
+    let secondBucketId;
+    let colorBucketId;
+    let nodeSizeId;
+    let edgeSizeId;
+
+    // constiables for agg ids, ex. id: "3" from one of the aggs (currently in $scope.vis.aggs)
+    let edgeSizeAggId;
+
+    // constiables for tooltip text
+    let primaryNodeTermName;
+    let secondaryNodeTermName;
+    let edgeSizeTermName;
+    let nodeSizeTermName;
+
+    function getTooltipTitle(termName, termValue, sizeTerm = null, sizeValue = null) {
+      let tooltipTitle = termName + ': ' + termValue;
+      if (sizeTerm !== null) {
+        tooltipTitle += '<br/>' + sizeTerm + ': ' + sizeValue;
+      }
+      return tooltipTitle;
     }
 
-    $scope.initialShows = function () {
-        $("#" + network_id).show();
-        $("#" + loading_id).show();
-        $("#errorHtml").hide();
-    }
-
-    $scope.startDynamicResize = function (network) {
-        new ResizeSensor($("#" + network_id), function () {
-            network.setSize('100%', '100%');
-        });
-    }
-
-    $scope.drawColorLegend = function (usedColors, colorDicc) {
-        var canvas = document.getElementsByTagName("canvas")[0];
-        var context = canvas.getContext("2d");
-
-        // Fill in text
-        context.fillStyle = "black";
-        context.font = "bold 30px Arial";
-        context.textAlign = "start";
-        context.fillText("COLOR LEGEND:", canvas.width * (-1), canvas.height * (-1));
-
-        var height = 40; // adds a preliminary buffer for the legend title
-        var currentHeightOnCanvas = canvas.height * (-1) + height;
-        var largestWidth = context.measureText("COLOR LEGEND:").width;
-
-        for (var key in colorDicc) {
-            context.fillStyle = colorDicc[key];
-            context.font = "bold 20px Arial";
-            context.fillText(key, canvas.width * (-1), currentHeightOnCanvas);
-            height += 22;
-            currentHeightOnCanvas = canvas.height * (-1) + height;
-
-            var currentWidth = context.measureText(key).width;
-            if (currentWidth > largestWidth) {
-                largestWidth = currentWidth; 
-            }
+    if (resp) {
+      // helper function to get column id
+      const getColumnIdByAggId = function getColumnIdByAggId(aggId) {
+        return resp.columns.find(function(col) {
+          return col.id.split('-')[2] === aggId;
+        }).id;
+      };
+
+      function getColumnNameFromColumnId(columnId) {
+        return resp.columns.find(colObj => colObj.id === columnId).name;
+      }
+
+      $scope.vis.aggs.aggs.forEach(agg => {
+        if (agg.__schema.name === 'first') {
+          // firstSecondBucketId is the secondary node in a node-node
+          // it also has a schema name of 'first', so set it if the first node is already set
+          //
+          // The metric used to return both primary and secondary nodes will always contain a colon,
+          // since it will take the form of "metric: order", for example, "DestIP: Descending"
+          // This might look confusing in a tooltip, so only the term name is used here
+          if (firstFirstBucketId) {
+            firstSecondBucketId = getColumnIdByAggId(agg.id);
+            secondaryNodeTermName = getColumnNameFromColumnId(firstSecondBucketId).split(':')[0];
+          } else {
+            firstFirstBucketId = getColumnIdByAggId(agg.id);
+            primaryNodeTermName = getColumnNameFromColumnId(firstFirstBucketId).split(':')[0];
+          }
+        } else if (agg.__schema.name === 'second') {
+          secondBucketId = getColumnIdByAggId(agg.id);
+        } else if (agg.__schema.name === 'colornode') {
+          colorBucketId = getColumnIdByAggId(agg.id);
+        } else if (agg.__schema.name === 'size_node') {
+          nodeSizeId = getColumnIdByAggId(agg.id);
+          nodeSizeTermName = getColumnNameFromColumnId(nodeSizeId);
+        } else if (agg.__schema.name === 'size_edge') {
+          edgeSizeAggId = agg.id;
         }
+      });
+
+      // Getting edge size id here to ensure all other buckets were located in the aggs already (future-proofing
+      // in case the order of the aggs being returned changes)
+      if (edgeSizeAggId) {
+        if (firstFirstBucketId && (firstSecondBucketId || secondBucketId)) {
+          edgeSizeId = 'col-5-' + edgeSizeAggId;
+          edgeSizeTermName = getColumnNameFromColumnId(edgeSizeId);
+        }
+      }
+
+      // Get the buckets of the aggregation
+      const buckets = resp.rows;
+      const colorDicc = {};
+      const usedColors = [];
+
+      // It is neccessary to add a timeout in order to have more than 1 net in the same dashboard
+      $timeout(function() {
+        networkId = 'net_' + $scope.$id;
+        loadingId = 'loading_' + $scope.$parent.$id;
+        $('#' + loadingId).hide();
+
+        // Single NODE or NODE-NODE Type
+        if ((firstFirstBucketId || firstSecondBucketId) && !secondBucketId) {
+          $scope.initialShows();
+          $('.secondNode').show();
+
+          /// DATA PARSED AND BUILDING NODES
+          const dataParsed = [];
+          // Iterate the buckets
+          let i = 0;
+          let dataNodes = buckets.map(function(bucket) {
+            const result = $.grep(dataParsed, function(e) {
+              return e.keyFirstNode === bucket[firstFirstBucketId];
+            });
 
-        // Shade in the legend
-        context.fillStyle = "rgba(218, 218, 218, 0.25)";
-        context.fillRect(canvas.width * (-1) - 20, canvas.height * (-1) - 40, largestWidth + 40, height + 60);
-    }
+            // first time we've parsed a node with this id
+            if (result.length === 0) {
+              dataParsed[i] = {};
 
-    $scope.$watchMulti(['esResponse', 'vis.params.secondNodeColor'], function ([resp]) {
-        // variables for column ids, ex. id: "col-0-3" from one of the 'columns' in the resp
-        let firstFirstBucketId, firstSecondBucketId, secondBucketId, colorBucketId, nodeSizeId, edgeSizeId
+              dataParsed[i].keyFirstNode = bucket[firstFirstBucketId];
 
-        // variables for agg ids, ex. id: "3" from one of the aggs (currently in $scope.vis.aggs)
-        let edgeSizeAggId
+              const value = bucket[nodeSizeId];
 
-        // variables for tooltip text
-        let primaryNodeTermName, secondaryNodeTermName, edgeSizeTermName, nodeSizeTermName
+              // Don't show nodes under the value
+              if ($scope.vis.params.minCutMetricSizeNode > value) {
+                dataParsed.splice(i, 1);
+                return;
+              }
 
-        function getTooltipTitle(termName, termValue, sizeTerm = null, sizeValue = null) {
-            let tooltipTitle = termName + ": " + termValue;
-            if (sizeTerm !== null) {
-                tooltipTitle += "<br/>"+sizeTerm + ": " + sizeValue; 
-            }
-            return tooltipTitle;
-        }
+              dataParsed[i].valorSizeNode = value;
+              dataParsed[i].nodeColorValue = 'default';
+              dataParsed[i].nodeColorKey = 'default';
+              if (!dataParsed[i].relationWithSecondNode) {
+                dataParsed[i].relationWithSecondNode = [];
+              }
 
-        if (resp) {
-            // helper function to get column id
-            var getColumnIdByAggId = function getColumnIdByAggId(aggId) {
-                return resp.columns.find(function (col) {
-                    return col.id.split('-')[2] === aggId;
-                }).id;
-            };
+              // Iterate rows and choose the edge size
+              if (firstSecondBucketId) {
+                let sizeEdgeVal = 0.1;
 
-            function getColumnNameFromColumnId(columnId) {
-                return resp.columns.find(colObj => colObj.id == columnId).name
-            }
+                if (edgeSizeId) {
+                  sizeEdgeVal = bucket[edgeSizeId];
+                }
 
-            $scope.vis.aggs.aggs.forEach((agg) => {
-                if (agg.__schema.name === "first") {
-                    // firstSecondBucketId is the secondary node in a node-node
-                    // it also has a schema name of 'first', so set it if the first node is already set
-                    //
-                    // The metric used to return both primary and secondary nodes will always contain a colon,
-                    // since it will take the form of "metric: order", for example, "DestIP: Descending"
-                    // This might look confusing in a tooltip, so only the term name is used here
-                    if (firstFirstBucketId) {
-                        firstSecondBucketId = getColumnIdByAggId(agg.id)
-                        secondaryNodeTermName = getColumnNameFromColumnId(firstSecondBucketId).split(':')[0]
-                    } else {
-                        firstFirstBucketId = getColumnIdByAggId(agg.id)
-                        primaryNodeTermName = getColumnNameFromColumnId(firstFirstBucketId).split(':')[0]
+                const relation = {
+                  keySecondNode: bucket[firstSecondBucketId],
+                  countMetric: bucket[nodeSizeId],
+                  widthOfEdge: sizeEdgeVal,
+                };
+                dataParsed[i].relationWithSecondNode.push(relation);
+              }
+
+              if (colorBucketId) {
+                if (colorDicc[bucket[colorBucketId]]) {
+                  dataParsed[i].nodeColorKey = bucket[colorBucketId];
+                  dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
+                } else {
+                  //repeat to find a NO-REPEATED color
+                  while (true) {
+                    const confirmColor = randomColor();
+                    if (usedColors.indexOf(confirmColor) === -1) {
+                      colorDicc[bucket[colorBucketId]] = confirmColor;
+                      dataParsed[i].nodeColorKey = bucket[colorBucketId];
+                      dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
+                      usedColors.push(confirmColor);
+                      break;
                     }
-                } else if (agg.__schema.name === "second") {
-                    secondBucketId = getColumnIdByAggId(agg.id)
-                } else if (agg.__schema.name === "colornode") {
-                    colorBucketId = getColumnIdByAggId(agg.id);
-                } else if (agg.__schema.name === "size_node") {
-                    nodeSizeId = getColumnIdByAggId(agg.id)
-                    nodeSizeTermName = getColumnNameFromColumnId(nodeSizeId)
-                } else if (agg.__schema.name === "size_edge") {
-                    edgeSizeAggId = agg.id
+                  }
                 }
-            });
-
-            // Getting edge size id here to ensure all other buckets were located in the aggs already (future-proofing
-            // in case the order of the aggs being returned changes)
-            if (edgeSizeAggId) {
-                if (firstFirstBucketId && (firstSecondBucketId || secondBucketId)) {
-                    edgeSizeId = "col-5-" + edgeSizeAggId;
-                    edgeSizeTermName = getColumnNameFromColumnId(edgeSizeId)
+              }
+
+              let colorNodeFinal = $scope.vis.params.firstNodeColor;
+              // Assign color and the content of the popup
+              if (dataParsed[i].nodeColorValue !== 'default') {
+                colorNodeFinal = dataParsed[i].nodeColorValue;
+              }
+
+              i++;
+
+              // Return the node totally built
+              const nodeReturn = {
+                id: i,
+                key: bucket[firstFirstBucketId],
+                color: colorNodeFinal,
+                shape: $scope.vis.params.shapeFirstNode,
+                value: value,
+                font: {
+                  color: $scope.vis.params.labelColor,
+                },
+              };
+
+              // If activated, show the labels
+              if ($scope.vis.params.showLabels) {
+                nodeReturn.label = bucket[firstFirstBucketId];
+              }
+
+              // If activated, show the popups
+              if ($scope.vis.params.showPopup) {
+                nodeReturn.title = getTooltipTitle(
+                  primaryNodeTermName,
+                  bucket[firstFirstBucketId],
+                  nodeSizeTermName,
+                  nodeReturn.value
+                );
+              }
+
+              return nodeReturn;
+            } else if (result.length === 1) {
+              // we already have this node id in dataNodes, so update with new info
+              const dataParsedNodeExist = result[0];
+              //Iterate rows and choose the edge size
+              if (firstSecondBucketId) {
+                let sizeEdgeVal = 0.1;
+                if (edgeSizeId) {
+                  sizeEdgeVal = bucket[edgeSizeId];
                 }
-            }
 
-            // Get the buckets of the aggregation
-            var buckets = resp.rows;
-
-            // It is neccessary to add a timeout in order to have more than 1 net in the same dashboard
-            $timeout(function () {
-                network_id = "net_" + $scope.$id;
-                loading_id = "loading_" + $scope.$parent.$id;
-                $("#" + loading_id).hide();
+                const relation = {
+                  keySecondNode: bucket[firstSecondBucketId],
+                  countMetric: bucket[nodeSizeId],
+                  widthOfEdge: sizeEdgeVal,
+                };
+                dataParsedNodeExist.relationWithSecondNode.push(relation);
+              }
+              return undefined;
+            }
+          });
 
-                // Single NODE or NODE-NODE Type
-                if ((firstFirstBucketId || firstSecondBucketId) && !secondBucketId) {
-                    $scope.initialShows();
-                    $(".secondNode").show();
+          // Clean "undefined" out of the array
+          dataNodes = dataNodes.filter(Boolean);
 
-                    if (colorBucketId) {
-                        var colorDicc = {};
-                        var usedColors = [];
-                    }
-
-                    /// DATA PARSED AND BUILDING NODES
-                    var dataParsed = [];
-                    // Iterate the buckets
-                    var i = 0;
-                    var dataNodes = buckets.map(function (bucket) {
-
-                        var result = $.grep(dataParsed, function (e) { return e.keyFirstNode == bucket[firstFirstBucketId]; });
-                        // first time we've parsed a node with this id
-                        if (result.length == 0) {
-                            dataParsed[i] = {};
-
-                            dataParsed[i].keyFirstNode = bucket[firstFirstBucketId];
-
-                            var value = bucket[nodeSizeId]
-
-                            // Don't show nodes under the value
-                            if ($scope.vis.params.minCutMetricSizeNode > value) {
-                                dataParsed.splice(i, 1);
-                                return;
-                            }
-
-                            dataParsed[i].valorSizeNode = value;
-                            dataParsed[i].nodeColorValue = "default";
-                            dataParsed[i].nodeColorKey = "default";
-                            if (!dataParsed[i].relationWithSecondNode) {
-                                dataParsed[i].relationWithSecondNode = [];
-                            }
-
-                            // Iterate rows and choose the edge size
-                            if (firstSecondBucketId) {
-                                if (edgeSizeId) {
-                                    var sizeEdgeVal = bucket[edgeSizeId];
-                                } else {
-                                    var sizeEdgeVal = 0.1;
-                                }
-
-
-                                var relation = {
-                                    keySecondNode: bucket[firstSecondBucketId],
-                                    countMetric: bucket[nodeSizeId],
-                                    widthOfEdge: sizeEdgeVal
-                                }
-                                dataParsed[i].relationWithSecondNode.push(relation)
-                            }
-
-
-                            if (colorBucketId) {
-                                if (colorDicc[bucket[colorBucketId]]) {
-                                    dataParsed[i].nodeColorKey = bucket[colorBucketId];
-                                    dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
-                                } else {
-                                    //repeat to find a NO-REPEATED color
-                                    while (true) {
-                                        var confirmColor = randomColor();
-                                        if (usedColors.indexOf(confirmColor) == -1) {
-                                            colorDicc[bucket[colorBucketId]] = confirmColor;
-                                            dataParsed[i].nodeColorKey = bucket[colorBucketId];
-                                            dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
-                                            usedColors.push(confirmColor);
-                                            break;
-                                        }
-                                    }
-                                }
-                            }
-
-                            // Assign color and the content of the popup
-                            if (dataParsed[i].nodeColorValue != "default") {
-                                var colorNodeFinal = dataParsed[i].nodeColorValue;
-                            } else {
-                                var colorNodeFinal = $scope.vis.params.firstNodeColor;
-                            }
-
-                            i++;
-
-                            // Return the node totally built
-                            var nodeReturn = {
-                                id: i,
-                                key: bucket[firstFirstBucketId],
-                                color: colorNodeFinal,
-                                shape: $scope.vis.params.shapeFirstNode,
-                                value: value,
-                                font: {
-                                    color: $scope.vis.params.labelColor
-                                }
-                            }
-
-                            // If activated, show the labels
-                            if ($scope.vis.params.showLabels) {
-                                nodeReturn.label = bucket[firstFirstBucketId];
-                            }
-
-                            // If activated, show the popups
-                            if ($scope.vis.params.showPopup) {
-                                nodeReturn.title = getTooltipTitle(primaryNodeTermName, bucket[firstFirstBucketId], nodeSizeTermName, nodeReturn.value);
-                            }
-
-                            return nodeReturn;
-
-
-                        } else if (result.length == 1) { // we already have this node id in dataNodes, so update with new info
-                            var dataParsed_node_exist = result[0]
-                            //Iterate rows and choose the edge size
-                            if (firstSecondBucketId) {
-                                if (edgeSizeId) {
-                                    var sizeEdgeVal = bucket[edgeSizeId];
-                                } else {
-                                    var sizeEdgeVal = 0.1;
-                                }
-
-                                var relation = {
-                                    keySecondNode: bucket[firstSecondBucketId],
-                                    countMetric: bucket[nodeSizeId],
-                                    widthOfEdge: sizeEdgeVal
-                                }
-                                dataParsed_node_exist.relationWithSecondNode.push(relation)
-                            }
-                            return undefined
-                        }
-                    });
-                    // Clean "undefined" out of the array
-                    dataNodes = dataNodes.filter(Boolean);
-
-                    // BUILDING EDGES AND SECONDARY NODES
-                    var dataEdges = [];
-                    for (var n = 0; n < dataParsed.length; n++) {
-                        // Find in the array the node with the keyFirstNode
-                        var result = $.grep(dataNodes, function (e) { return e.key == dataParsed[n].keyFirstNode; });
-                        if (result.length == 0) {
-                            console.log("Network Plugin Error: Node not found");
-                        } else if (result.length == 1) {
-                            // Found the node, access to its id
-                            if (firstSecondBucketId) {
-                                for (var r = 0; r < dataParsed[n].relationWithSecondNode.length; r++) {
-                                    // Find in the relations the second node to relate
-                                    var nodeOfSecondType = $.grep(dataNodes, function (e) { return e.key == dataParsed[n].relationWithSecondNode[r].keySecondNode; });
-                                    
-                                    if (nodeOfSecondType.length == 0) {
-                                        // This is the first time this secondary node has been processed
-                                        i++;
-                                        var secondaryNode = {
-                                            id: i,
-                                            key: dataParsed[n].relationWithSecondNode[r].keySecondNode,
-                                            label: dataParsed[n].relationWithSecondNode[r].keySecondNode,
-                                            color: $scope.vis.params.secondNodeColor,
-                                            font: {
-                                                color: $scope.vis.params.labelColor
-                                            },
-                                            shape: $scope.vis.params.shapeSecondNode
-                                        };
-                                        if ($scope.vis.params.showPopup) {
-                                            secondaryNode.title = getTooltipTitle(secondaryNodeTermName, dataParsed[n].relationWithSecondNode[r].keySecondNode);
-                                        }
-                                        // Add a new secondary node
-                                        dataNodes.push(secondaryNode);
-
-                                        // Create a new edge between a primary and secondary node
-                                        var edge = {
-                                            from: result[0].id,
-                                            to: dataNodes[dataNodes.length - 1].id,
-                                            value: dataParsed[n].relationWithSecondNode[r].widthOfEdge
-                                        }
-                                        if ($scope.vis.params.showPopup && edgeSizeId) {
-                                            edge.title = getTooltipTitle(edgeSizeTermName, dataParsed[n].relationWithSecondNode[r].widthOfEdge);
-                                        }
-                                        dataEdges.push(edge);
-
-                                    } else if (nodeOfSecondType.length == 1) {
-                                        // The secondary node being processed already exists,
-                                        //    only a new edge needs to be created 
-                                        var enlace = {
-                                            from: result[0].id,
-                                            to: nodeOfSecondType[0].id,
-                                            value: dataParsed[n].relationWithSecondNode[r].widthOfEdge
-                                        }
-                                        if ($scope.vis.params.showPopup && edgeSizeId) {
-                                            enlace.title = getTooltipTitle(edgeSizeTermName, dataParsed[n].relationWithSecondNode[r].widthOfEdge);
-                                        }
-                                        dataEdges.push(enlace);
-                                    } else {
-                                        console.log("Network Plugin Error: Multiple nodes with same id found");
-                                    }
-                                }
-                            }
-                        } else {
-                            console.log("Network Plugin Error: Multiple nodes with same id found");
-                        }
+          // BUILDING EDGES AND SECONDARY NODES
+          const dataEdges = [];
+          for (let n = 0; n < dataParsed.length; n++) {
+            // Find in the array the node with the keyFirstNode
+            const result = $.grep(dataNodes, function(e) {
+              return e.key === dataParsed[n].keyFirstNode;
+            });
+            if (result.length === 0) {
+              console.log('Network Plugin Error: Node not found');
+            } else if (result.length === 1) {
+              // Found the node, access to its id
+              if (firstSecondBucketId) {
+                for (let r = 0; r < dataParsed[n].relationWithSecondNode.length; r++) {
+                  // Find in the relations the second node to relate
+                  const nodeOfSecondType = $.grep(dataNodes, function(e) {
+                    return e.key === dataParsed[n].relationWithSecondNode[r].keySecondNode;
+                  });
+
+                  if (nodeOfSecondType.length === 0) {
+                    // This is the first time this secondary node has been processed
+                    i++;
+                    const secondaryNode = {
+                      id: i,
+                      key: dataParsed[n].relationWithSecondNode[r].keySecondNode,
+                      label: dataParsed[n].relationWithSecondNode[r].keySecondNode,
+                      color: $scope.vis.params.secondNodeColor,
+                      font: {
+                        color: $scope.vis.params.labelColor,
+                      },
+                      shape: $scope.vis.params.shapeSecondNode,
+                    };
+                    if ($scope.vis.params.showPopup) {
+                      secondaryNode.title = getTooltipTitle(
+                        secondaryNodeTermName,
+                        dataParsed[n].relationWithSecondNode[r].keySecondNode
+                      );
                     }
-
-                    // Creation of the network with the library
-                    var nodesDataSet = new visN.DataSet(dataNodes);
-                    var edgesDataSet = new visN.DataSet(dataEdges);
-
-                    var container = document.getElementById(network_id);
-                    container.style.height = container.getBoundingClientRect().height;
-                    container.height = container.getBoundingClientRect().height;
-                    var data = {
-                        nodes: nodesDataSet,
-                        edges: edgesDataSet
+                    // Add a new secondary node
+                    dataNodes.push(secondaryNode);
+
+                    // Create a new edge between a primary and secondary node
+                    const edge = {
+                      from: result[0].id,
+                      to: dataNodes[dataNodes.length - 1].id,
+                      value: dataParsed[n].relationWithSecondNode[r].widthOfEdge,
                     };
-                    // Options controlled by user directly
-                    var options_1 = {
-                        height: container.getBoundingClientRect().height.toString(),
-                        physics: {
-                            barnesHut: {
-                                gravitationalConstant: $scope.vis.params.gravitationalConstant,
-                                springConstant: $scope.vis.params.springConstant
-                            }
-                        },
-                        edges: {
-                            arrowStrikethrough: false,
-                            smooth: {
-                                type: $scope.vis.params.smoothType
-                            },
-                            scaling: {
-                                min: $scope.vis.params.minEdgeSize,
-                                max: $scope.vis.params.maxEdgeSize
-                            }
-                        },
-                        nodes: {
-                            physics: $scope.vis.params.nodePhysics,
-                            scaling: {
-                                min: $scope.vis.params.minNodeSize,
-                                max: $scope.vis.params.maxNodeSize
-                            }
-                        },
-                        layout: {
-                            improvedLayout: !(dataEdges.length > 200)
-                        },
-                        interaction: {
-                            hover: true,
-                            tooltipDelay: 50 
-                        },
-                        manipulation: {
-                            enabled: true
-                        }
+                    if ($scope.vis.params.showPopup && edgeSizeId) {
+                      edge.title = getTooltipTitle(
+                        edgeSizeTermName,
+                        dataParsed[n].relationWithSecondNode[r].widthOfEdge
+                      );
+                    }
+                    dataEdges.push(edge);
+                  } else if (nodeOfSecondType.length === 1) {
+                    // The secondary node being processed already exists,
+                    //    only a new edge needs to be created
+                    const enlace = {
+                      from: result[0].id,
+                      to: nodeOfSecondType[0].id,
+                      value: dataParsed[n].relationWithSecondNode[r].widthOfEdge,
                     };
-                    switch ($scope.vis.params.posArrow) {
-                        case 'from':
-                            var options_2 = {
-                                edges: {
-                                    arrows: {
-                                        from: {
-                                            enabled: $scope.vis.params.displayArrow,
-                                            scaleFactor: $scope.vis.params.scaleArrow,
-                                            type: $scope.vis.params.shapeArrow
-                                        }
-                                    }
-                                }
-                            };
-                            break;
-                        case 'middle':
-                            var options_2 = {
-                                edges: {
-                                    arrows: {
-                                        middle: {
-                                            enabled: $scope.vis.params.displayArrow,
-                                            scaleFactor: $scope.vis.params.scaleArrow,
-                                            type: $scope.vis.params.shapeArrow
-                                        }
-                                    }
-                                }
-                            };
-                            break;
-                        case 'to':
-                            var options_2 = {
-                                edges: {
-                                    arrows: {
-                                        to: {
-                                            enabled: $scope.vis.params.displayArrow,
-                                            scaleFactor: $scope.vis.params.scaleArrow,
-                                            type: $scope.vis.params.shapeArrow
-                                        }
-                                    }
-                                }
-                            };
-                            break;
-                        default:
-                            var options_2 = {
-                                edges: {
-                                    arrows: {
-                                        from: {
-                                            enabled: $scope.vis.params.displayArrow,
-                                            scaleFactor: $scope.vis.params.scaleArrow,
-                                            type: $scope.vis.params.shapeArrow
-                                        }
-                                    }
-                                }
-                            };
-                            break;
+                    if ($scope.vis.params.showPopup && edgeSizeId) {
+                      enlace.title = getTooltipTitle(
+                        edgeSizeTermName,
+                        dataParsed[n].relationWithSecondNode[r].widthOfEdge
+                      );
                     }
-                    var options = angular.merge(options_1, options_2);
-                    console.log("Network Plugin: Create network now");
-                    var network = new visN.Network(container, data, options);
-
-                    $scope.startDynamicResize(network);
-
-                    network.on("afterDrawing", function (canvasP) {
-                        $("#" + loading_id).hide();
-                        // Draw the color legend if Node Color is activated
-                        if (colorBucketId  && $scope.vis.params.showColorLegend) {
-                            $scope.drawColorLegend(usedColors, colorDicc);
-                        }
-                    });
-
-                  // NODE-RELATION Type
-                } else if (secondBucketId && !firstSecondBucketId) {
-                    $scope.initialShows();
-                    $(".secondNode").hide();
-
-                    if (colorBucketId) {
-                        var colorDicc = {};
-                        var usedColors = [];
-
-                        // Check if "Node Color" is the last selection
-                        if (colorBucketId <= secondBucketId) {
-                            $scope.errorNodeColor();
-                            return;
-                        }
+                    dataEdges.push(enlace);
+                  } else {
+                    console.log('Network Plugin Error: Multiple nodes with same id found');
+                  }
+                }
+              }
+            } else {
+              console.log('Network Plugin Error: Multiple nodes with same id found');
+            }
+          }
+
+          const container = document.getElementById(networkId);
+          // container.style.height = String(container.getBoundingClientRect().height);
+          // container.height = String(container.getBoundingClientRect().height);
+          const data = {
+            nodes: dataNodes,
+            edges: dataEdges,
+          };
+
+          // Options controlled by user directly
+          const options1 = {
+            // height: container.getBoundingClientRect().height.toString(),
+            physics: {
+              barnesHut: {
+                gravitationalConstant: $scope.vis.params.gravitationalConstant,
+                springConstant: $scope.vis.params.springConstant,
+              },
+            },
+            edges: {
+              arrowStrikethrough: false,
+              smooth: {
+                type: $scope.vis.params.smoothType,
+              },
+              scaling: {
+                min: $scope.vis.params.minEdgeSize,
+                max: $scope.vis.params.maxEdgeSize,
+              },
+            },
+            nodes: {
+              physics: $scope.vis.params.nodePhysics,
+              scaling: {
+                min: $scope.vis.params.minNodeSize,
+                max: $scope.vis.params.maxNodeSize,
+              },
+            },
+            layout: {
+              improvedLayout: !(dataEdges.length > 200),
+            },
+            interaction: {
+              hover: true,
+              tooltipDelay: 50,
+            },
+            manipulation: {
+              enabled: true,
+            },
+          };
+
+          let options2 = null;
+
+          switch ($scope.vis.params.posArrow) {
+            case 'from':
+              options2 = {
+                edges: {
+                  arrows: {
+                    from: {
+                      enabled: $scope.vis.params.displayArrow,
+                      scaleFactor: $scope.vis.params.scaleArrow,
+                      type: $scope.vis.params.shapeArrow,
+                    },
+                  },
+                },
+              };
+              break;
+            case 'middle':
+              options2 = {
+                edges: {
+                  arrows: {
+                    middle: {
+                      enabled: $scope.vis.params.displayArrow,
+                      scaleFactor: $scope.vis.params.scaleArrow,
+                      type: $scope.vis.params.shapeArrow,
+                    },
+                  },
+                },
+              };
+              break;
+            case 'to':
+              options2 = {
+                edges: {
+                  arrows: {
+                    to: {
+                      enabled: $scope.vis.params.displayArrow,
+                      scaleFactor: $scope.vis.params.scaleArrow,
+                      type: $scope.vis.params.shapeArrow,
+                    },
+                  },
+                },
+              };
+              break;
+            default:
+              options2 = {
+                edges: {
+                  arrows: {
+                    from: {
+                      enabled: $scope.vis.params.displayArrow,
+                      scaleFactor: $scope.vis.params.scaleArrow,
+                      type: $scope.vis.params.shapeArrow,
+                    },
+                  },
+                },
+              };
+              break;
+          }
+
+          const options = angular.merge(options1, options2);
+          console.log('Network Plugin: Create network now');
+          const network = new Network(container, data, options);
+
+          network.on('afterDrawing', function() {
+            $('#' + loadingId).hide();
+
+            // Draw the color legend if Node Color is activated
+            if (colorBucketId && $scope.vis.params.showColorLegend) {
+              $scope.drawColorLegend(usedColors, colorDicc);
+            }
+          });
+
+          // NODE-RELATION Type
+        } else if (secondBucketId && !firstSecondBucketId) {
+          $scope.initialShows();
+          $('.secondNode').hide();
+
+          if (colorBucketId) {
+            // Check if "Node Color" is the last selection
+            if (colorBucketId <= secondBucketId) {
+              $scope.errorNodeColor();
+              return;
+            }
+          }
+
+          // DATA PARSED AND BUILDING NODES
+          const dataParsed = [];
+          // Iterate the buckets
+          let i = 0;
+          let dataNodes = buckets.map(function(bucket) {
+            const result = $.grep(dataParsed, function(e) {
+              return e.keyNode === bucket[firstFirstBucketId];
+            });
+            // first time we've parsed a node with this id
+            if (result.length === 0) {
+              dataParsed[i] = {};
+              dataParsed[i].keyNode = bucket[firstFirstBucketId];
+
+              const value = bucket[nodeSizeId];
+
+              // Don't show nodes under the value
+              if ($scope.vis.params.minCutMetricSizeNode > value) {
+                dataParsed.splice(i, 1);
+                return;
+              }
+
+              dataParsed[i].valorSizeNode = value;
+              dataParsed[i].nodeColorValue = 'default';
+              dataParsed[i].nodeColorKey = 'default';
+              dataParsed[i].relationWithSecondField = [];
+
+              // Add relation edges
+              let sizeEdgeVal = 0.1;
+              if (edgeSizeId) {
+                sizeEdgeVal = bucket[edgeSizeId];
+              }
+
+              // Get the color of the node, save in the dictionary
+              if (colorBucketId) {
+                if (colorDicc[bucket[colorBucketId]]) {
+                  dataParsed[i].nodeColorKey = bucket[colorBucketId];
+                  dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
+                } else {
+                  // repeat to find a NO-REPEATED color
+                  while (true) {
+                    const confirmColor = randomColor();
+                    if (usedColors.indexOf(confirmColor) === -1) {
+                      colorDicc[bucket[colorBucketId]] = confirmColor;
+                      dataParsed[i].nodeColorKey = bucket[colorBucketId];
+                      dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
+                      usedColors.push(confirmColor);
+                      break;
                     }
-
-                    // DATA PARSED AND BUILDING NODES
-                    var dataParsed = [];
-                    // Iterate the buckets
-                    var i = 0;
-                    var dataNodes = buckets.map(function (bucket) {
-                        var result = $.grep(dataParsed, function (e) { return e.keyNode == bucket[firstFirstBucketId]; });
-                        // first time we've parsed a node with this id
-                        if (result.length == 0) {
-                            dataParsed[i] = {};
-                            dataParsed[i].keyNode = bucket[firstFirstBucketId];
-
-                            var value = bucket[nodeSizeId];
-
-                            // Don't show nodes under the value
-                            if ($scope.vis.params.minCutMetricSizeNode > value) {
-                                dataParsed.splice(i, 1);
-                                return;
-                            }
-                  
-                            dataParsed[i].valorSizeNode = value;
-                            dataParsed[i].nodeColorValue = "default";
-                            dataParsed[i].nodeColorKey = "default";
-                            dataParsed[i].relationWithSecondField = []
-
-                            // Add relation edges
-                            if (edgeSizeId) {
-                                var sizeEdgeVal = bucket[edgeSizeId];
-                            } else {
-                                var sizeEdgeVal = 0.1;
-                            }
-
-                            // Get the color of the node, save in the dictionary
-                            if (colorBucketId) {
-                                if (colorDicc[bucket[colorBucketId]]) {
-                                    dataParsed[i].nodeColorKey = bucket[colorBucketId];
-                                    dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
-                                } else {
-                                    // repeat to find a NO-REPEATED color
-                                    while (true) {
-                                        var confirmColor = randomColor();
-                                        if (usedColors.indexOf(confirmColor) == -1) {
-                                            colorDicc[bucket[colorBucketId]] = confirmColor;
-                                            dataParsed[i].nodeColorKey = bucket[colorBucketId];
-                                            dataParsed[i].nodeColorValue = colorDicc[bucket[colorBucketId]];
-                                            usedColors.push(confirmColor);
-                                            break;
-                                        }
-                                    }
-
-                                }
-                            }
-
-                            var relation = {
-                                keyRelation: bucket[secondBucketId],
-                                countMetric: bucket[nodeSizeId],
-                                widthOfEdge: sizeEdgeVal
-                            };
-                            dataParsed[i].relationWithSecondField.push(relation)
-
-                            if (dataParsed[i].nodeColorValue != "default") {
-                                var colorNodeFinal = dataParsed[i].nodeColorValue;
-                            } else {
-                                var colorNodeFinal = $scope.vis.params.firstNodeColor;
-                            }
-
-                            i++;
-
-                            // Return the node totally built
-                            var nodeReturn = {
-                                id: i,
-                                key: bucket[firstFirstBucketId],
-                                color: colorNodeFinal,
-                                shape: $scope.vis.params.shapeFirstNode,
-                                value: value,
-                                font: {
-                                    color: $scope.vis.params.labelColor
-                                }
-                            }
-
-                            // If activated, show the labels
-                            if ($scope.vis.params.showLabels) {
-                                nodeReturn.label = bucket[firstFirstBucketId];
-                            }
-
-                            // If activated, show the popups
-                            if ($scope.vis.params.showPopup) {
-                                nodeReturn.title = getTooltipTitle(primaryNodeTermName, bucket[firstFirstBucketId], nodeSizeTermName, nodeReturn.value);
-                            }
-
-                            return nodeReturn;
-                        } else if (result.length == 1) {  // we already have this node id in dataNodes, so update with new info
-                            var dataParsed_node_exist = result[0]
-                            if (edgeSizeId) {
-                                var sizeEdgeVal = bucket[edgeSizeId];
-                            } else {
-                                var sizeEdgeVal = 0.1;
-                            }
-
-                            var relation = {
-                                keyRelation: bucket[secondBucketId],
-                                countMetric: bucket[nodeSizeId],
-                                widthOfEdge: sizeEdgeVal
-                            }
-                            dataParsed_node_exist.relationWithSecondField.push(relation)
-                            return undefined
-                        }
+                  }
+                }
+              }
+
+              const relation = {
+                keyRelation: bucket[secondBucketId],
+                countMetric: bucket[nodeSizeId],
+                widthOfEdge: sizeEdgeVal,
+              };
+              dataParsed[i].relationWithSecondField.push(relation);
+
+              let colorNodeFinal = $scope.vis.params.firstNodeColor;
+              if (dataParsed[i].nodeColorValue !== 'default') {
+                colorNodeFinal = dataParsed[i].nodeColorValue;
+              }
+
+              i++;
+
+              // Return the node totally built
+              const nodeReturn = {
+                id: i,
+                key: bucket[firstFirstBucketId],
+                color: colorNodeFinal,
+                shape: $scope.vis.params.shapeFirstNode,
+                value: value,
+                font: {
+                  color: $scope.vis.params.labelColor,
+                },
+              };
+
+              // If activated, show the labels
+              if ($scope.vis.params.showLabels) {
+                nodeReturn.label = bucket[firstFirstBucketId];
+              }
+
+              // If activated, show the popups
+              if ($scope.vis.params.showPopup) {
+                nodeReturn.title = getTooltipTitle(
+                  primaryNodeTermName,
+                  bucket[firstFirstBucketId],
+                  nodeSizeTermName,
+                  nodeReturn.value
+                );
+              }
+
+              return nodeReturn;
+            } else if (result.length === 1) {
+              // we already have this node id in dataNodes, so update with new info
+              const dataParsedNodeExist = result[0];
+              let sizeEdgeVal = 0.1;
+              if (edgeSizeId) {
+                sizeEdgeVal = bucket[edgeSizeId];
+              }
+
+              const relation = {
+                keyRelation: bucket[secondBucketId],
+                countMetric: bucket[nodeSizeId],
+                widthOfEdge: sizeEdgeVal,
+              };
+              dataParsedNodeExist.relationWithSecondField.push(relation);
+              return undefined;
+            }
+          });
+
+          // BUILDING EDGES
+          // Clean "undefinded" in the array
+          dataNodes = dataNodes.filter(Boolean);
+          const dataEdges = [];
+
+          // Iterate parsed nodes
+          for (let n = 0; n < dataParsed.length; n++) {
+            // Obtain id of the node
+            const NodoFrom = $.grep(dataNodes, function(e) {
+              return e.key === dataParsed[n].keyNode;
+            });
+            if (NodoFrom.length === 0) {
+              console.log('Network Plugin Error: Node not found');
+            } else if (NodoFrom.length === 1) {
+              const idFrom = NodoFrom[0].id;
+              // Iterate relations that have with the second field selected
+              for (let p = 0; p < dataParsed[n].relationWithSecondField.length; p++) {
+                // Iterate again the nodes
+                for (let z = 0; z < dataParsed.length; z++) {
+                  // Check that we don't compare the same node
+                  if (dataParsed[n] !== dataParsed[z]) {
+                    const NodoTo = $.grep(dataNodes, function(e) {
+                      return e.key === dataParsed[z].keyNode;
                     });
-
-                    // BUILDING EDGES
-                    // Clean "undefinded" in the array
-                    dataNodes = dataNodes.filter(Boolean);
-                    var dataEdges = [];
-
-                    // Iterate parsed nodes
-                    for (var n = 0; n < dataParsed.length; n++) {
-                        // Obtain id of the node
-                        var NodoFrom = $.grep(dataNodes, function (e) { return e.key == dataParsed[n].keyNode; });
-                        if (NodoFrom.length == 0) {
-                            console.log("Network Plugin Error: Node not found");
-                        } else if (NodoFrom.length == 1) {
-                            var id_from = NodoFrom[0].id;
-                            // Iterate relations that have with the second field selected
-                            for (var p = 0; p < dataParsed[n].relationWithSecondField.length; p++) {
-                                // Iterate again the nodes
-                                for (var z = 0; z < dataParsed.length; z++) {
-                                    // Check that we don't compare the same node
-                                    if (dataParsed[n] != dataParsed[z]) {
-                                        var NodoTo = $.grep(dataNodes, function (e) { return e.key == dataParsed[z].keyNode; });
-                                        if (NodoTo.length == 0) {
-                                            console.log("Network Plugin Error: Node not found");
-                                        } else if (NodoTo.length == 1) {
-                                            var id_to = NodoTo[0].id;
-                                            // Have relation?
-                                            var sameRelation = $.grep(dataParsed[z].relationWithSecondField, function (e) { return e.keyRelation == dataParsed[n].relationWithSecondField[p].keyRelation; });
-                                            if (sameRelation.length == 1) {
-                                                // Nodes have a relation, creating the edge
-                                                var edgeExist = $.grep(dataEdges, function (e) { return (e.to == id_from && e.from == id_to) || (e.to == id_to && e.from == id_from); });
-                                                if (edgeExist.length == 0) {
-                                                    // The size of the edge is the total of the common
-                                                    var sizeEdgeTotal = sameRelation[0].widthOfEdge + dataParsed[n].relationWithSecondField[p].widthOfEdge;
-                                                    var edge = {
-                                                        from: id_from,
-                                                        to: id_to,
-                                                        value: sizeEdgeTotal
-                                                    };
-                                                    dataEdges.push(edge);
-                                                }
-                                            }
-                                        } else {
-                                            console.log("Network Plugin Error: Multiples nodes with same id found");
-                                        }
-                                    }
-                                }
-                            }
-
-                        } else {
-                            console.log("Network Plugin Error: Multiples nodes with same id found");
-                        }
-                    }
-
-                    // Creation of the network with the library
-                    var nodesDataSet = new visN.DataSet(dataNodes);
-                    var edgesDataSet = new visN.DataSet(dataEdges);
-
-
-                    // Creation of the network
-                    var container = document.getElementById(network_id);
-                    // Set the Height
-                    container.style.height = container.getBoundingClientRect().height;
-                    container.height = container.getBoundingClientRect().height;
-                    // Set the Data
-                    var data = {
-                        nodes: nodesDataSet,
-                        edges: edgesDataSet
-                    };
-                    // Set the Options
-                    var options = {
-                        height: container.getBoundingClientRect().height.toString(),
-                        physics: {
-                            barnesHut: {
-                                gravitationalConstant: $scope.vis.params.gravitationalConstant,
-                                springConstant: $scope.vis.params.springConstant,
-                                springLength: 500
-                            }
-                        },
-                        edges: {
-                            arrows: {
-                                to: {
-                                    enabled: $scope.vis.params.displayArrow,
-                                    scaleFactor: $scope.vis.params.scaleArrow,
-                                    type: $scope.vis.params.shapeArrow
-                                }
-                            },
-                            arrowStrikethrough: false,
-                            smooth: {
-                                type: $scope.vis.params.smoothType
-                            },
-                            scaling: {
-                                min: $scope.vis.params.minEdgeSize,
-                                max: $scope.vis.params.maxEdgeSize
-                            }
-                        },
-                        interaction: {
-                            hideEdgesOnDrag: true,
-                            hover: true,
-                            tooltipDelay: 100
-                        },
-                        nodes: {
-                            physics: $scope.vis.params.nodePhysics,
-                            scaling: {
-                                min: $scope.vis.params.minNodeSize,
-                                max: $scope.vis.params.maxNodeSize
-                            }
-                        },
-                        layout: {
-                            improvedLayout: false
-                        },
-                        manipulation: {
-                            enabled: true
+                    if (NodoTo.length === 0) {
+                      console.log('Network Plugin Error: Node not found');
+                    } else if (NodoTo.length === 1) {
+                      const idTo = NodoTo[0].id;
+                      // Have relation?
+                      const sameRelation = $.grep(dataParsed[z].relationWithSecondField, function(
+                        e
+                      ) {
+                        return (
+                          e.keyRelation === dataParsed[n].relationWithSecondField[p].keyRelation
+                        );
+                      });
+                      if (sameRelation.length === 1) {
+                        // Nodes have a relation, creating the edge
+                        const edgeExist = $.grep(dataEdges, function(e) {
+                          return (
+                            (e.to === idFrom && e.from === idTo) ||
+                            (e.to === idTo && e.from === idFrom)
+                          );
+                        });
+                        if (edgeExist.length === 0) {
+                          // The size of the edge is the total of the common
+                          const sizeEdgeTotal =
+                            sameRelation[0].widthOfEdge +
+                            dataParsed[n].relationWithSecondField[p].widthOfEdge;
+                          const edge = {
+                            from: idFrom,
+                            to: idTo,
+                            value: sizeEdgeTotal,
+                          };
+                          dataEdges.push(edge);
                         }
+                      }
+                    } else {
+                      console.log('Network Plugin Error: Multiples nodes with same id found');
                     }
-                    console.log("Network Plugin: Create network now");
-                    var network = new visN.Network(container, data, options);
-
-                    $scope.startDynamicResize(network);
-
-                    network.on("afterDrawing", function (canvasP) {
-                        $("#" + loading_id).hide();
-                        // Draw the color legend if Node Color is activated
-                        if (colorBucketId && $scope.vis.params.showColorLegend) {
-                            $scope.drawColorLegend(usedColors, colorDicc);
-                        }
-                    });
-                } else {
-                    $scope.errorNodeNodeRelation();
+                  }
                 }
-            });
+              }
+            } else {
+              console.log('Network Plugin Error: Multiples nodes with same id found');
+            }
+          }
+
+          // Creation of the network
+          const container = document.getElementById(networkId);
+          // Set the Height
+          // container.style.height = String(container.getBoundingClientRect().height);
+          // container.height = String(container.getBoundingClientRect().height);
+          // Set the Data
+          const data = {
+            nodes: dataNodes,
+            edges: dataEdges,
+          };
+          // Set the Options
+          const options = {
+            // height: container.getBoundingClientRect().height.toString(),
+            physics: {
+              barnesHut: {
+                gravitationalConstant: $scope.vis.params.gravitationalConstant,
+                springConstant: $scope.vis.params.springConstant,
+                springLength: 500,
+              },
+            },
+            edges: {
+              arrows: {
+                to: {
+                  enabled: $scope.vis.params.displayArrow,
+                  scaleFactor: $scope.vis.params.scaleArrow,
+                  type: $scope.vis.params.shapeArrow,
+                },
+              },
+              arrowStrikethrough: false,
+              smooth: {
+                type: $scope.vis.params.smoothType,
+              },
+              scaling: {
+                min: $scope.vis.params.minEdgeSize,
+                max: $scope.vis.params.maxEdgeSize,
+              },
+            },
+            interaction: {
+              hideEdgesOnDrag: true,
+              hover: true,
+              tooltipDelay: 100,
+            },
+            nodes: {
+              physics: $scope.vis.params.nodePhysics,
+              scaling: {
+                min: $scope.vis.params.minNodeSize,
+                max: $scope.vis.params.maxNodeSize,
+              },
+            },
+            layout: {
+              improvedLayout: false,
+            },
+            manipulation: {
+              enabled: true,
+            },
+          };
+
+          console.log('Network Plugin: Create network now');
+          const network = new Network(container, data, options);
+
+          network.on('afterDrawing', function() {
+            $('#' + loadingId).hide();
+            // Draw the color legend if Node Color is activated
+            if (colorBucketId && $scope.vis.params.showColorLegend) {
+              $scope.drawColorLegend(usedColors, colorDicc);
+            }
+          });
+        } else {
+          $scope.errorNodeNodeRelation();
         }
-    });
+      });
+    }
+  });
 });
-
diff --git a/public/network_vis_params.html b/public/network_vis_params.html
index 5e8f99d..980dad2 100644
--- a/public/network_vis_params.html
+++ b/public/network_vis_params.html
@@ -1,24 +1,20 @@
 <br>
 <h5><strong>Color Options</strong></h5>
 <br>
-<div>
-  <span>Background:</span>
-  <input type="color" ng-model="vis.params.canvasBackgroundColor" class="form-control"/>
-</div>
 
 <div>
   <span>Primary Nodes:</span>
-  <input type="color" ng-model="vis.params.firstNodeColor" class="form-control"/>
+  <input type="color" ng-model="editorState.params.firstNodeColor" class="form-control"/>
 </div>
 
 <div>
   <span>Secondary Nodes:</span>
-  <input type="color" ng-model="vis.params.secondNodeColor" class="form-control"/>
+  <input type="color" ng-model="editorState.params.secondNodeColor" class="form-control"/>
 </div>
 
 <div>
   <span>Labels:</span>
-  <input type="color" ng-model="vis.params.labelColor" class="form-control"/>
+  <input type="color" ng-model="editorState.params.labelColor" class="form-control"/>
 </div>
 
 <br>
@@ -30,19 +26,19 @@
     <tbody>
         <tr>
             <td>Max Node Size&nbsp;</td>
-            <td><input type="number" ng-model="vis.params.maxNodeSize" min="1"></td>
+            <td><input class="euiFieldNumber" type="number" ng-model="editorState.params.maxNodeSize" min="1"></td>
         </tr>
         <tr>
             <td>Min Node Size&nbsp;</td>
-            <td><input type="number" ng-model="vis.params.minNodeSize" min="1"></td>
+            <td><input class="euiFieldNumber" type="number" ng-model="editorState.params.minNodeSize" min="1"></td>
         </tr>
         <tr>
             <td>Max Edge Width&nbsp;</td>
-            <td><input type="number" ng-model="vis.params.maxEdgeSize" min="1"></td>
+            <td><input class="euiFieldNumber" type="number" ng-model="editorState.params.maxEdgeSize" min="1"></td>
         </tr>
         <tr>
             <td>Min Edge Width&nbsp;</td>
-            <td><input type="number" ng-model="vis.params.minEdgeSize" min="0.1"></td>
+            <td><input class="euiFieldNumber" type="number" ng-model="editorState.params.minEdgeSize" min="0.1"></td>
         </tr>
     </tbody>
 </table>
@@ -54,7 +50,7 @@
 <br>
 <div class="form-group">
   <label for="sel1">Primary Nodes: </label>
-   <select class="form-control" ng-model="vis.params.shapeFirstNode" id="sel1">
+   <select class="form-control" ng-model="editorState.params.shapeFirstNode" id="sel1">
      <option value="circle">Circle</option>
      <option value="dot">Dot</option>
      <option value="ellipse">Ellipse</option>
@@ -71,7 +67,7 @@
 
 <div class="form-group">
   <label for="sel2">Secondary Nodes: </label>
-   <select class="form-control" ng-model="vis.params.shapeSecondNode" id="sel2">
+   <select class="form-control" ng-model="editorState.params.shapeSecondNode" id="sel2">
      <option value="circle">Circle</option>
      <option value="dot">Dot</option>
      <option value="ellipse">Ellipse</option>
@@ -94,12 +90,12 @@
     <tbody>
         <tr>
             <td>Display directional edge:&nbsp;</td>
-            <td><input type="checkbox" ng-model="vis.params.displayArrow"></td>
+            <td><input class="euiCheckbox__input" type="checkbox" ng-model="editorState.params.displayArrow"></td>
         </tr>
         <tr>
             <td>Endpoint position:&nbsp;</td>
             <td>
-                <select class="form-control" ng-model="vis.params.posArrow" id="sel4">
+                <select class="form-control" ng-model="editorState.params.posArrow" id="sel4">
                     <option value="from">Beginning</option>
                     <option value="middle">Middle</option>
                     <option value="to">End side</option>
@@ -109,7 +105,7 @@
         <tr>
             <td>Endpoint Type:</td>
             <td>
-                <select class="form-control" ng-model="vis.params.shapeArrow" id="sel3">
+                <select class="form-control" ng-model="editorState.params.shapeArrow" id="sel3">
                     <option value="arrow">Arrow</option>
                     <option value="circle">Circle</option>
                 </select>
@@ -117,12 +113,12 @@
         </tr>
         <tr>
             <td>Scale Factor:</td>
-            <td><input type="number" ng-model="vis.params.scaleArrow" min="0"></td>
+            <td><input type="number" class="euiFieldNumber" ng-model="editorState.params.scaleArrow" min="0"></td>
         </tr>
         <tr>
             <td>Smooth type:</td>
             <td>
-                <select class="form-control" ng-model="vis.params.smoothType" id="sel5">
+                <select class="form-control" ng-model="editorState.params.smoothType" id="sel5">
                     <option value="dynamic">Dynamic</option>
                     <option value="continuous">Continuous Anchor</option>
                     <option value="discrete">Discrete Anchor</option>
@@ -145,19 +141,19 @@
 <h5><strong>Extra</strong></h5>
 <div class="checkbox">
   <label>
-    <input type="checkbox" ng-model="vis.params.showLabels">
+    <input class="euiCheckbox__input" type="checkbox" ng-model="editorState.params.showLabels">
     Show Labels
   </label>
   <label>
-    <input type="checkbox" ng-model="vis.params.showPopup">
+    <input class="euiCheckbox__input" type="checkbox" ng-model="editorState.params.showPopup">
     Show Popup
   </label>
   <label>
-    <input type="checkbox" ng-model="vis.params.showColorLegend">
+    <input class="euiCheckbox__input" type="checkbox" ng-model="editorState.params.showColorLegend">
     Show Color Legend (Node Color selected)
   </label>
   <label>
-    <input type="checkbox" ng-model="vis.params.nodePhysics">
+    <input class="euiCheckbox__input" type="checkbox" ng-model="editorState.params.nodePhysics">
     Nodes Acting like Springs
   </label>
 </div>
@@ -168,11 +164,11 @@
 <br>
 <div>
   Attraction Force
-  <input type="number" ng-model="vis.params.gravitationalConstant" id="gravC">
+  <input class="euiFieldNumber" type="number" ng-model="editorState.params.gravitationalConstant" id="gravC">
 </div>
 <div>
   Spring Force
-  <input type="number" ng-model="vis.params.springConstant" id="springC">
+  <input class="euiFieldNumber" step="0.001" type="number" ng-model="editorState.params.springConstant" id="springC">
 </div>
 
 <br>
@@ -180,7 +176,7 @@
 <h4>Don't show nodes below this value:</h4>
 <div>
   Node Size
-  <input type="number" ng-model="vis.params.minCutMetricSizeNode" min="0">
+  <input class="euiFieldNumber" type="number" ng-model="editorState.params.minCutMetricSizeNode" min="0">
 </div>
 
 <br>
diff --git a/public/plugin.ts b/public/plugin.ts
new file mode 100644
index 0000000..1219bfc
--- /dev/null
+++ b/public/plugin.ts
@@ -0,0 +1,25 @@
+import { PluginInitializerContext, CoreSetup, CoreStart, Plugin } from '../../../../core/public';
+import { VisualizationsSetup } from '../../../src/legacy/core_plugins/visualizations/public';
+import { networkVisTypeDefinition } from './network_vis';
+
+/** @internal */
+export interface NetworkVisPluginSetupDependencies {
+  visualizations: VisualizationsSetup;
+}
+
+/** @internal */
+export class NetworkVisPlugin implements Plugin<void, void> {
+  initializerContext: PluginInitializerContext;
+
+  constructor(initializerContext: PluginInitializerContext) {
+    this.initializerContext = initializerContext;
+  }
+
+  public setup(core: CoreSetup, { visualizations }: NetworkVisPluginSetupDependencies) {
+    visualizations.types.createBaseVisualization(networkVisTypeDefinition);
+  }
+
+  public start(core: CoreStart) {
+    // nothing to do here yet
+  }
+}
-- 
2.17.1

